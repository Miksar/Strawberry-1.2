
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Strawberry // Описание дополнений</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="_tpl/style.css" rel="stylesheet" type="text/css" media="screen">
</head>

<body>

<h1>Оглавление</h1>
<ul>
<li><a href="#Введение">Введение</a></li>
<li><a href="#rss.php">rss.php</a></li>
<li><a href="#print.php">print.php</a></li>
<li><a href="#trackback.php">trackback.php</a></li>
<li><a href="#remote_headlines.php">remote_headlines.php</a></li>
<li><a href="#show_search.php">show_search.php</a></li>
<li><a href="#show_users.php">show_users.php</a></li>
<li><a href="#xmlrpc.php">xmlrpc.php</a></li>
<li><a href="#Keywords">Keywords</a></li>
<li><a href="#Post Type">Post Type</a></li>
<li><a href="#Drag'n'Drop Blocks">Drag'n'Drop Blocks</a></li>
</ul>
<h1><a name="Введение"></a><small><a href="#top">[^]</a></small>&nbsp;Введение</h1>
<p>В стандартный дистрибудив Strawberry входят несколько хаков и много плагинов. Так или иначе они расширяют возможности скрипта, придают гибкость и много чего ещё хорошего.</p>
<p>Все плагины хранятся в папке plugins/. Плагины требуют инсталяции, которая крайне проста: нужно закинуть фаил в папку с плагинами, а потом в админки включить плагин. Если понадобится, плагин можно и отключить, как понимаете. Если плагин является многоязыковым, то к нему прилогается фаил с расширением ini (сам плагин имеет расширение php), этот фаил нужно закинуть в папку inc/lang/ваш_язык/plugins/.</p>
<p>Дополнения обычно храняться в директории со скриптом (rss.php, show_users.php - это дополнения). Некоторые (show_search.php, например) нужно подключать</p>
<p class="code">include rootpath.'/show_search.php';</p>
<p>Другие (print.php) в этом не нуждаются, т.к. именно через них идёт вывод.</p>
<p>Если вместе с аддоном идёт фаил с расширением ini, то его нужно закинуть в папку inc/lang/ваш_язык/addons/.</p>
<p>Как вы наверное заметили, дополнения имеющие префикс show_ рассчитаны на подключение: show_search.php, show_users.php.</p>
<h1><a name="rss.php"></a><small><a href="#top">[^]</a></small>&nbsp;rss.php</h1>
<p>Дополнение позволяет выводить новости в формате RSS 2.0 для обработки их какой-нибудь читалкой. Часть дополнения это шаблон RSS, кторый лежит в папке с шаблонами и может быть изменён на ваше усмотрение.<br>
 Справедливости ради, нужно сказать, что RSS работает почти для всего: новости, категории, пользователи и т.д. Очень удобно.</p>
<h1><a name="print.php"></a><small><a href="#top">[^]</a></small>&nbsp;print.php</h1>
<p>Нехитрый аддон выдающий новость в формате пригодном для печати. Часть дополнения - шаблон Print.</p>
<h1><a name="trackback.php"></a><small><a href="#top">[^]</a></small>&nbsp;trackback.php</h1>
<p>Позволяет одним постом убить двух зайцев. Система такая: сайт А написал заметку про зайцев, предположим, вы страстный фанат этих ушастых животных и тоже пишите заметку опровергающюю доводы сайта А. В форму для трэкбэков вы пихаете TrackBack URI заметки про зайцев сайта А и таким образом комментируете эту заметку, но ещё и пишите что-то у себя. Более <a href="http://www.yandex.ru/yandsearch?rpt=rad&text=trackback">подробное описание ищите в Яндексе</a>.</p>
<p>Частью дополнения является плагин TrackBack, который позволяет модерировать присланные трэкбэки и слать свои.</p>
<h1><a name="remote_headlines.php"></a><small><a href="#top">[^]</a></small>&nbsp;remote_headlines.php</h1>
<p>С помощью этого дополнения пользователи смогут транслировать ваши заголовки (или полные новости, см. ниже) у себя на сайте через обычную явускрипт:</p>
<p class="code">&lt;script language=&quot;javascript&quot; src=&quot;http://example.com/path/to/remote_headlines.php&quot;&gt;&lt;/script&gt;</p>
<p>Более подробное описание вы найдёте в самом файле remote_headlines.php, открыть его можно любым текстовым редактором.</p>
<p>Частью дополнения является шаблон remote_headlines, в нём можно настроить вывод: давать только заголовки, давать категории и т.д.</p>
<h1><a name="show_search.php"></a><small><a href="#top">[^]</a></small>&nbsp;show_search.php</h1>
<p>Это движок поиска, не форма! Форму вы найдёте открыв сам фаил в текстовом редакторе. Часть дополнения - шаблон Search.</p>
<h1><a name="show_users.php"></a><small><a href="#top">[^]</a></small>&nbsp;show_users.php</h1>
<p>Показывает список пользователей системы. Внешний вид и всякое такое :) можно настроить через шаблон Users.</p>
<h1><a name="xmlrpc.php"></a><small><a href="#top">[^]</a></small>&nbsp;xmlrpc.php</h1>
<p>Это XML-RPC гейт, дополнение позволяет добавлять/редактировать/удалять новости через десктоп-программу w.bloggar. Описание настройки с картинками вы <a href="http://strawberry.goodgirl.ru/docs/w.bloggar/">найдёте тут</a>.</p>
<h1><a name="Keywords"></a><small><a href="#top">[^]</a></small>&nbsp;Keywords</h1>
<p>Плагин Keywords расширяет классификацию. Помимо категорий посту можно присваивать кейворды. Добавлять кейворды можно в окне добавления/редактирования новости, в текстовое поле вводится слово или несколько. Разделять несколько слов нужно переносом строки, т.е. одна строка это один кейворд. При добавлении или сохранении новости введённые в поля слова добавляются в базу и присваиваются посту.</p>
<p>Кейворды в отличии от категорий &quot;плоские&quot;, у них нет никакой иерархии. Ключсловам это и не нужно, они являются ярлыками записи и нуждаются в иерархии лишь в случае отсутствия в системе категорий (или близких по смыслу понятий, например, рубрик).</p>
<p>Для сортировки по ключевым словам перед инклудом show_news.php нужно писать:</p>
<p class="code">$keywords = 'key1,key2'; // key1 и key2 это то же самое, что поле &quot;УРЛ&quot; у категорий, только задаётся автоматически, через транслит</p>
<p class="code">$keywords = '1,2'; // 1 и 2 - ID, задаются автоматически и не повторяются</p>
<p class="code">$keywords = 'Key1,Key2'; // Key1 и Key2 это имена кейвордов</p>
<p>В вышеуказаных примерах будут выводится все посты с кейвордами Key1 и Key2.</p>
<p>Чтобы посмотреть кейворды указанные для новости в шаблоне, нужно указывать <em>$tpl['post']['_']['keywords']</em> - это выведет что-то типа &quot;1,2&quot; (без кавычек), вывести готовый вид (имена со ссылками) можно через <em>$tpl['post']['keywords']</em>.</p>
<p>В массив $post кейворды тоже попадают:</p>
<p class="code">$number = 5;<br>
 include rootpath.'/show_news.php';<br>
 <br>
 if ($post['keywords']){ // узнаём, открыта ли какая-то новость и указаны ли для неё кейворды<br>
    
$static['skip'] = 0; <br>
 $static['template'] = 'Headlines';<br>
 $static['number'] = 7;<br>
 $static['category'] = $post['keywords'];<br>
 include rootpath.'/show_news.php'; <br>
 }</p>
<p>Вышеуказанный пример это практически калька с <a href="readme.html">примера категорий</a>. Смысл примера: вывести 5 последних новостей и если новость открыта, то под ней 7 постов с похожими кейвордами. На сайтах СМИ это называется &quot;новости по теме&quot;.</p>
<p>Пример &quot;новостей по теме&quot;. Вы пишите новость, указываете кейворды &quot;Путин&quot;, &quot;А лох-то кто?&quot; и &quot;Киркоров&quot;. Все другие новости, которым присвоен кейворд &quot;Киркоров&quot; являются &quot;по теме&quot;.</p>
<h1><a name="Post Type"></a><small><a href="#top">[^]</a></small>&nbsp;Post Type</h1>
<p>Если позволите, а выбор у вас небольшой :), объясню смысл этого плагина.</p>
<p>Возникло желание классифицировать обычный стандартный пост по нескольким параметрам. Есть, к примеру, нужда делать страницу, при этом запись не должна попадать в общую ленту, создавать отдельную категорию - не с руки, ибо нужна и иерархия страниц. То есть одна страница может быть &quot;родителем&quot; другой и &quot;ребёнком&quot; третьей, но при этом не является &quot;папкой&quot;. Банальный пример: страница &quot;Обо мне&quot; её &quot;ребёнок&quot; &quot;Контакты&quot;.</p>
<p>Получается, что новость она как бы уже и не новость совсем, а страница, опрос, приватный пост или чистый php.</p>
<p>Итак, на данный момент типов всего четыре и я их перечислил выше. В чём их различия.</p>
<p><em>Страница</em> не выводится в общем потоке и имеет иерархию. Когда в админке выбирается тип &quot;Страница&quot; снизу появляется ещё одно выподающее меню, в котором можно выбрать &quot;родителя&quot; - другой пост указаный как &quot;страница&quot;.</p>
<p><em>Опрос</em> позволяет сделать голосовалку, которая появится в общем потоке. Любой текст в короткой новости становится пунктом опроса. Принцип прост - одна строка это один пункт. Полная новость становится выводом результатов, при этом не важно заполняли вы её или нет - ваши данные видны не будут, только результаты. Если вы проголосовали, то записываются куки сроком на сутки и в короткой новости у вас тоже только результаты. После голосования кем-либо записываются голоса, но не в отдельную базу, а в сам пост:</p>
<p class="code">Пункт 1{кол-во голосов}<br>
 Пункт 2{кол-во голосов}<br>
 Пункт 3{кол-во голосов}</p>
<p><em>Запароленый</em> пост это приватный пост, пост на который поставлен пароль, если кто-то не знает пароль и не введёт его, то кроме формы ввода пароля ничего не увидит. Запаролить пост просто - нужно выбрать тип &quot;Запароленый&quot;, появится новое поле и туда следует ввести пароль. Просто, как три копейки.</p>
<p><em>PHP</em> пост это пост, который содержит только валидный php. php-теги писать не нужно, просто код и всё. Такой тип поста доступен только человеку с полными правами, по умолчанию существует только одна группа с такими правами - &quot;Администраторы&quot;. Люди, которым позволино редактировать чужые посты могут править пост и сохранять его, но после правки php работать не будет, он превратится в текст.</p>
<p>Чтобы вызвать только определённый тип нужно использовать переменную <em>$type</em>:</p>
<p class="code">$type = 'poll'; // выведет только опросы<br>
 $type = 'page'; // выведет только страницы</p>
<p>Если $type не указывать будет выводиться всё, кроме страниц.</p>
<h1><a name="Drag'n'Drop Blocks"></a><small><a href="#top">[^]</a></small>&nbsp;Drag'n'Drop Blocks</h1>
<p>Очень задорный плагин, он создан только лишь потому что хотелось. Я давно желал увидить &quot;блоки своей мечты&quot; в каком-нибудь ином движке, но не удавалось, ибо нет или просто в тех движках, которых смотрел нет. Не знаю на сколько плагин будет полезен в полной мере, но при создании странички примера помог. Всё оказалось достаточно удобным. Конечно, делать ещё и делать, но то, что имеется очень удачное, как мне кажется.</p>
<p>Плагин делится на две части. Первая находится в админке и через неё создаются блоки (обычные файлы) и их категории (папки). Вторая часть находится в самой странице, в которой в самом низу (после &lt;/html&gt;) подключён foot.php:</p>
<p class="code">include plugins_directory.'/ddb/foot.php';</p>
<p>Если набрать в адресной строке <em>http://example.com/ваша-страница.php?ddb=edit</em>, то появятся поля, в которые можно перетащить блоки. Эти поля появляются не абы как, прежде нужно сделать разметку:</p>
<p class="code">&lt;!--block:NAME--&gt;</p>
<p><em>NAME</em> это любое слово, кроме blocks. Очень советую как следует изучить для этого дела example/index.php из дистрибутива. Там есть и подключение foot.php (вы можете увидить что такое низ страницы :)) и немного разметки. Самого кода - кот наплакал, поэтому всё должно быть предельно ясно.</p>
<p>Ещё одна интересная деталь. Предположем, есть у нас набор страниц:<br />
http://example.com/ваша-страница.php?key=i<br />
http://example.com/ваша-страница.php?key=see<br />
http://example.com/ваша-страница.php?key=nude<br />
http://example.com/ваша-страница.php?key=people</p>
<p>(далее я буду писать просто <em>?key=что-то_непостоянное</em>)</p>
<p>Каждая такая штука подключает что-то или выводит. Что обычно приходится писать в таких случаях:</p>
<p class="code">if ($key == 'i'){<br />
 что-то если key равно i<br />
} elseif ($key == 'see'){<br />
что-то если key равно see<br />
} else {<br />
если key не равно ни i, ни see<br />
}</p>
<p>С Drag'n'Drop Blocks от этого можно избавиться. Если у нас есть шаблон с расставленными полями (см. про &lt;!--block:NAME--&gt;), то всё делается проще. В админке Drag'n'Drop Blocks можно создать категорию с родителем NAMEи именем- key. Теперь в этой категории создаём блоки с именами i, see, nude и people. Теперь при совпадении $key в блок NAME будет подключаться нужный блок. Если правило не совпадает, то подключается блок else. Конечно, если такой блок есть.</p>
<p>Красотища! :)</p>

</body>
</html>